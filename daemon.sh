#!/bin/bash

# Rearrange the order of options below according to what you would like to see in the help message.
# ARG_OPTIONAL_BOOLEAN([reload],[r],[Reload daemon instead of getting the output],[])
# ARG_POSITIONAL_SINGLE([path],[Path to the accelerator directory],[/srv/accelerator])
# ARG_DEFAULTS_POS()
# ARG_HELP([Script to manage an accelerator daemon. By default tries to find a running daemon and print results to stdio])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.7.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info


die()
{
    local _ret=$2
    test -n "$_ret" || _ret=1
    test "$_PRINT_HELP" = yes && print_help >&2
    echo "$1" >&2
    exit ${_ret}
}


begins_with_short_option()
{
    local first_option all_short_options='rh'
    first_option="${1:0:1}"
    test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_path="/srv/accelerator"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_reload="off"


print_help()
{
    printf '%s\n' "Script to manage an accelerator daemon. By default tries to find a running daemon and print results to stdio"
    printf 'Usage: %s [-r|--(no-)reload] [-h|--help] [<path>]\n' "$0"
    printf '\t%s\n' "<path>: Path to the accelerator directory (default: '/srv/accelerator')"
    printf '\t%s\n' "-r, --reload, --no-reload: Reload daemon instead of getting the output (off by default)"
    printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
    _positionals_count=0
    while test $# -gt 0
    do
	_key="$1"
	case "$_key" in
	    -r|--no-reload|--reload)
		_arg_reload="on"
		test "${1:0:5}" = "--no-" && _arg_reload="off"
		;;
	    -r*)
		_arg_reload="on"
		_next="${_key##-r}"
		if test -n "$_next" -a "$_next" != "$_key"
		then
		    begins_with_short_option "$_next" && shift && set -- "-r" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
		fi
		;;
	    -h|--help)
		print_help
		exit 0
		;;
	    -h*)
		print_help
		exit 0
		;;
	    *)
		_last_positional="$1"
		_positionals+=("$_last_positional")
		_positionals_count=$((_positionals_count + 1))
		;;
	esac
	shift
    done
}


handle_passed_args_count()
{
    test "${_positionals_count}" -le 1 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 0 and 1, but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
    local _positional_name _shift_for=$1
    _positional_names="_arg_path "

    shift "$_shift_for"
    for _positional_name in ${_positional_names}
    do
	test $# -gt 0 || break
	eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
	shift
    done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

LOG=${_arg_path}/daemon.log

if [ "${_arg_reload}" = "on" ]
then
    sudo systemctl restart accelerator.service
    sleep 5
fi


if [ ! -f $LOG ]
then
    echo "ERROR: Log not found! Probably there isn't a daemon running in ${_arg_path}

"
    exit 1
else
    echo "Daemon currently running"
    tail -f $LOG
fi

# ] <-- needed because of Argbash
